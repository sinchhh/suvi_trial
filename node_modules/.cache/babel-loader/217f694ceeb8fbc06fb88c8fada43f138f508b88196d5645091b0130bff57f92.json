{"ast":null,"code":"const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n  let indentation = \"\";\n  if (options.format && options.indentBy.length > 0) {\n    indentation = EOL;\n  }\n  return arrToStr(jArray, options, \"\", indentation);\n}\nfunction arrToStr(arr, options, jPath, indentation) {\n  let xmlStr = \"\";\n  let isPreviousElementTag = false;\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const tagName = propName(tagObj);\n    let newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = `${jPath}.${tagName}`;\n    if (tagName === options.textNodeName) {\n      let tagText = tagObj[tagName];\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n      xmlStr += tagText;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n      isPreviousElementTag = true;\n      continue;\n    } else if (tagName[0] === \"?\") {\n      const attStr = attr_to_str(tagObj[\":@\"], options);\n      const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n      let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n      piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n      isPreviousElementTag = true;\n      continue;\n    }\n    let newIdentation = indentation;\n    if (newIdentation !== \"\") {\n      newIdentation += options.indentBy;\n    }\n    const attStr = attr_to_str(tagObj[\":@\"], options);\n    const tagStart = indentation + `<${tagName}${attStr}`;\n    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else if (tagValue && tagValue.endsWith(\">\")) {\n      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n    } else {\n      xmlStr += tagStart + \">\";\n      if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n        xmlStr += indentation + options.indentBy + tagValue + indentation;\n      } else {\n        xmlStr += tagValue;\n      }\n      xmlStr += `</${tagName}>`;\n    }\n    isPreviousElementTag = true;\n  }\n  return xmlStr;\n}\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== \":@\") return key;\n  }\n}\nfunction attr_to_str(attrMap, options) {\n  let attrStr = \"\";\n  if (attrMap && !options.ignoreAttributes) {\n    for (let attr in attrMap) {\n      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n      } else {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n      }\n    }\n  }\n  return attrStr;\n}\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n  for (let index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n  return false;\n}\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (let i = 0; i < options.entities.length; i++) {\n      const entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\nmodule.exports = toXml;","map":{"version":3,"names":["EOL","toXml","jArray","options","indentation","format","indentBy","length","arrToStr","arr","jPath","xmlStr","isPreviousElementTag","i","tagObj","tagName","propName","newJPath","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","endsWith","includes","obj","keys","Object","key","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"sources":["C:/Users/sinch/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
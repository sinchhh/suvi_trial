{"ast":null,"code":"import { __awaiter, __extends, __generator, __read, __spread } from \"tslib\";\nimport { ConsoleLogger as Logger } from '../Logger/ConsoleLogger';\nvar logger = new Logger('Util');\nvar NonRetryableError = /** @class */function (_super) {\n  __extends(NonRetryableError, _super);\n  function NonRetryableError(message) {\n    var _this = _super.call(this, message) || this;\n    _this.nonRetryable = true;\n    return _this;\n  }\n  return NonRetryableError;\n}(Error);\nexport { NonRetryableError };\nexport var isNonRetryableError = function (obj) {\n  var key = 'nonRetryable';\n  return obj && obj[key];\n};\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function retry(functionToRetry, args, delayFn, onTerminate) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _this = this;\n    return __generator(this, function (_a) {\n      if (typeof functionToRetry !== 'function') {\n        throw Error('functionToRetry must be a function');\n      }\n      return [2 /*return*/, new Promise(function (resolve, reject) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var attempt, terminated, timeout, wakeUp, lastError, _loop_1, state_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                attempt = 0;\n                terminated = false;\n                wakeUp = function () {};\n                onTerminate && onTerminate.then(function () {\n                  // signal not to try anymore.\n                  terminated = true;\n                  // stop sleeping if we're sleeping.\n                  clearTimeout(timeout);\n                  wakeUp();\n                });\n                _loop_1 = function () {\n                  var _a, _b, err_1, retryIn_1;\n                  return __generator(this, function (_c) {\n                    switch (_c.label) {\n                      case 0:\n                        attempt++;\n                        logger.debug(functionToRetry.name + \" attempt #\" + attempt + \" with this vars: \" + JSON.stringify(args));\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 3,, 7]);\n                        _a = {};\n                        _b = resolve;\n                        return [4 /*yield*/, functionToRetry.apply(void 0, __spread(args))];\n                      case 2:\n                        return [2 /*return*/, (_a.value = _b.apply(void 0, [_c.sent()]), _a)];\n                      case 3:\n                        err_1 = _c.sent();\n                        lastError = err_1;\n                        logger.debug(\"error on \" + functionToRetry.name, err_1);\n                        if (isNonRetryableError(err_1)) {\n                          logger.debug(functionToRetry.name + \" non retryable error\", err_1);\n                          return [2 /*return*/, {\n                            value: reject(err_1)\n                          }];\n                        }\n                        retryIn_1 = delayFn(attempt, args, err_1);\n                        logger.debug(functionToRetry.name + \" retrying in \" + retryIn_1 + \" ms\");\n                        if (!(retryIn_1 === false || terminated)) return [3 /*break*/, 4];\n                        return [2 /*return*/, {\n                          value: reject(err_1)\n                        }];\n                      case 4:\n                        return [4 /*yield*/, new Promise(function (r) {\n                          wakeUp = r; // export wakeUp for onTerminate handling\n                          timeout = setTimeout(wakeUp, retryIn_1);\n                        })];\n                      case 5:\n                        _c.sent();\n                        _c.label = 6;\n                      case 6:\n                        return [3 /*break*/, 7];\n                      case 7:\n                        return [2 /*return*/];\n                    }\n                  });\n                };\n\n                _a.label = 1;\n              case 1:\n                if (!!terminated) return [3 /*break*/, 3];\n                return [5 /*yield**/, _loop_1()];\n              case 2:\n                state_1 = _a.sent();\n                if (typeof state_1 === \"object\") return [2 /*return*/, state_1.value];\n                return [3 /*break*/, 1];\n              case 3:\n                // reached if terminated while waiting for a timer.\n                reject(lastError);\n                return [2 /*return*/];\n            }\n          });\n        });\n      })];\n    });\n  });\n}\n\nvar MAX_DELAY_MS = 5 * 60 * 1000;\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function jitteredBackoff(maxDelayMs) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n  var BASE_TIME_MS = 100;\n  var JITTER_FACTOR = 100;\n  return function (attempt) {\n    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n    return delay > maxDelayMs ? false : delay;\n  };\n}\n/**\n * @private\n * Internal use of Amplify only\n */\nexport var jitteredExponentialRetry = function (functionToRetry, args, maxDelayMs, onTerminate) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n  return retry(functionToRetry, args, jitteredBackoff(maxDelayMs), onTerminate);\n};","map":{"version":3,"names":["ConsoleLogger","Logger","logger","NonRetryableError","_super","__extends","message","_this","call","nonRetryable","Error","isNonRetryableError","obj","key","retry","functionToRetry","args","delayFn","onTerminate","Promise","resolve","reject","__awaiter","attempt","terminated","wakeUp","then","clearTimeout","timeout","debug","name","JSON","stringify","_b","apply","__spread","_c","sent","_a","lastError","err_1","retryIn_1","r","setTimeout","MAX_DELAY_MS","jitteredBackoff","maxDelayMs","BASE_TIME_MS","JITTER_FACTOR","delay","Math","pow","random","jitteredExponentialRetry"],"sources":["C:\\Users\\sinch\\node_modules\\@aws-amplify\\core\\src\\Util\\Retry.ts"],"sourcesContent":["import { DelayFunction } from '../types';\nimport { ConsoleLogger as Logger } from '../Logger/ConsoleLogger';\nconst logger = new Logger('Util');\n\nexport class NonRetryableError extends Error {\n\tpublic readonly nonRetryable = true;\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t}\n}\n\nexport const isNonRetryableError = (obj: any): obj is NonRetryableError => {\n\tconst key: keyof NonRetryableError = 'nonRetryable';\n\treturn obj && obj[key];\n};\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport async function retry<T>(\n\tfunctionToRetry: (...args: any[]) => T,\n\targs: any[],\n\tdelayFn: DelayFunction,\n\tonTerminate?: Promise<void>\n): Promise<T> {\n\tif (typeof functionToRetry !== 'function') {\n\t\tthrow Error('functionToRetry must be a function');\n\t}\n\n\treturn new Promise(async (resolve, reject) => {\n\t\tlet attempt = 0;\n\t\tlet terminated = false;\n\t\tlet timeout: any;\n\t\tlet wakeUp: any = () => {}; // will be replaced with a resolver()\n\n\t\t// used after the loop if terminated while waiting for a timer.\n\t\tlet lastError: Error;\n\n\t\tonTerminate &&\n\t\t\tonTerminate.then(() => {\n\t\t\t\t// signal not to try anymore.\n\t\t\t\tterminated = true;\n\n\t\t\t\t// stop sleeping if we're sleeping.\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\twakeUp();\n\t\t\t});\n\n\t\twhile (!terminated) {\n\t\t\tattempt++;\n\n\t\t\tlogger.debug(\n\t\t\t\t`${\n\t\t\t\t\tfunctionToRetry.name\n\t\t\t\t} attempt #${attempt} with this vars: ${JSON.stringify(args)}`\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\treturn resolve(await functionToRetry(...args));\n\t\t\t} catch (err) {\n\t\t\t\tlastError = err;\n\t\t\t\tlogger.debug(`error on ${functionToRetry.name}`, err);\n\n\t\t\t\tif (isNonRetryableError(err)) {\n\t\t\t\t\tlogger.debug(`${functionToRetry.name} non retryable error`, err);\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tconst retryIn = delayFn(attempt, args, err);\n\t\t\t\tlogger.debug(`${functionToRetry.name} retrying in ${retryIn} ms`);\n\n\t\t\t\t// we check `terminated` again here because it could have flipped\n\t\t\t\t// in the time it took `functionToRetry` to return.\n\t\t\t\tif (retryIn === false || terminated) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t} else {\n\t\t\t\t\tawait new Promise(r => {\n\t\t\t\t\t\twakeUp = r; // export wakeUp for onTerminate handling\n\t\t\t\t\t\ttimeout = setTimeout(wakeUp, retryIn);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// reached if terminated while waiting for a timer.\n\t\treject(lastError);\n\t});\n}\n\nconst MAX_DELAY_MS = 5 * 60 * 1000;\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function jitteredBackoff(\n\tmaxDelayMs: number = MAX_DELAY_MS\n): DelayFunction {\n\tconst BASE_TIME_MS = 100;\n\tconst JITTER_FACTOR = 100;\n\n\treturn attempt => {\n\t\tconst delay = 2 ** attempt * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n\t\treturn delay > maxDelayMs ? false : delay;\n\t};\n}\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport const jitteredExponentialRetry = <T>(\n\tfunctionToRetry: (...args: any[]) => T,\n\targs: any[],\n\tmaxDelayMs: number = MAX_DELAY_MS,\n\tonTerminate?: Promise<void>\n): Promise<T> =>\n\tretry(functionToRetry, args, jitteredBackoff(maxDelayMs), onTerminate);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}